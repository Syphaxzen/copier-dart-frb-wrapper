---
name: frb-patterns
description: Flutter Rust Bridge patterns and best practices for this project. Use when writing Rust API code, adding new bindings, implementing DartFn callbacks, or troubleshooting FRB issues.
---

# FRB Patterns for {{ package_name }}

Patterns and templates for writing correct Flutter Rust Bridge code in this project.

## Architecture Overview

```
┌─────────────────────────────────────────────────┐
│     Upstream Rust crate                         │  Core implementation
├─────────────────────────────────────────────────┤
│       rust/src/api/*.rs (Rust wrappers)         │  FRB-annotated functions
├─────────────────────────────────────────────────┤
│      lib/src/rust/*.dart (FRB generated)        │  Auto-generated Dart API
├─────────────────────────────────────────────────┤
│           Your Dart application code            │  Uses the API
└─────────────────────────────────────────────────┘
```

## Constructor-Style API Pattern

Use `impl` blocks for constructors so FRB generates idiomatic Dart:

```rust
#[frb(opaque)]
pub struct MyType {
    pub(crate) native: upstream_crate::MyType,
}

impl MyType {
    // Generates MyType.create() in Dart
    #[flutter_rust_bridge::frb(sync)]
    pub fn create(param: String) -> Result<MyType, String> {
        let native = upstream_crate::MyType::new(&param)
            .map_err(|e| e.to_string())?;
        Ok(MyType { native })
    }

    // Generates myType.serialize() in Dart
    #[flutter_rust_bridge::frb(sync)]
    pub fn serialize(&self) -> Vec<u8> {
        self.native.serialize().to_vec()
    }
}
```

```rust
// ❌ WRONG - generates myTypeCreate() as a top-level function in Dart
pub fn my_type_create(param: String) -> Result<MyType, String> { ... }
```

**Dart usage:**
```dart
final obj = MyType.create(param: 'value');  // Constructor-style
final bytes = obj.serialize();               // Method
```

## Opaque Type Pattern

Wrap upstream types in opaque structs to keep them in Rust:

```rust
#[frb(opaque)]
pub struct MyType {
    pub(crate) native: upstream_crate::MyType,
}

impl MyType {
    // Access native type internally
    pub(crate) fn native(&self) -> &upstream_crate::MyType {
        &self.native
    }
}
```

FRB manages the lifecycle automatically - no `dispose()` needed in Dart.

## Transparent Struct Pattern

For data types that cross FFI as plain values:

```rust
pub struct MyResult {
    pub data: Vec<u8>,
    pub count: u32,
}

pub enum MyEnum {
    OptionA,
    OptionB,
    OptionC,
}
```

FRB generates Dart classes/enums with constructors automatically.

## DartFn Callbacks for Store Operations

For operations requiring Dart store callbacks:

```rust
pub async fn operation_with_storage(
    data: Vec<u8>,
    // Store callbacks
    storage_read: impl Fn(Vec<u8>) -> DartFnFuture<Option<Vec<u8>>> + Send + Sync + 'static,
    storage_write: impl Fn(Vec<u8>, Vec<u8>) -> DartFnFuture<()> + Send + Sync + 'static,
) -> Result<Vec<u8>, String> {
    // Use callbacks to access Dart-side storage
    let stored = storage_read(key).await;
    storage_write(key, value).await;
    Ok(result)
}
```

### Bridging Sync Traits to Async Callbacks

If the upstream crate has sync trait methods but DartFn is async, use `futures::executor::block_on()`:

```rust
// In Cargo.toml: futures = "0.3"

fn sync_trait_method(&self) -> Result<(), Error> {
    futures::executor::block_on((self.callback)(data));
    Ok(())
}
```

This works because FRB runs Rust functions on separate threads, not the Dart isolate.

### Adapter Pattern for Upstream Traits

If the upstream crate defines traits (e.g., for storage), create adapter structs that bridge DartFn callbacks to trait implementations:

```rust
struct StoreAdapter<L, S>
where
    L: Fn(Vec<u8>) -> DartFnFuture<Option<Vec<u8>>> + Send + Sync + 'static,
    S: Fn(Vec<u8>, Vec<u8>) -> DartFnFuture<()> + Send + Sync + 'static,
{
    load: L,
    store: S,
}

#[async_trait(?Send)]
impl<L, S> upstream_crate::Store for StoreAdapter<L, S>
where
    L: Fn(Vec<u8>) -> DartFnFuture<Option<Vec<u8>>> + Send + Sync + 'static,
    S: Fn(Vec<u8>, Vec<u8>) -> DartFnFuture<()> + Send + Sync + 'static,
{
    async fn load(&self, key: &[u8]) -> Result<Option<Vec<u8>>, Error> {
        Ok((self.load)(key.to_vec()).await)
    }

    async fn store(&mut self, key: &[u8], value: &[u8]) -> Result<(), Error> {
        (self.store)(key.to_vec(), value.to_vec()).await;
        Ok(())
    }
}
```

This lets Dart-side store implementations satisfy Rust trait requirements via callbacks.

## Sync vs Async Functions

### Sync Functions (simple, no callbacks)

```rust
impl MyType {
    #[flutter_rust_bridge::frb(sync)]  // Mark as sync
    pub fn serialize(&self) -> Vec<u8> {
        self.native.serialize().to_vec()
    }
}
```

### Async Functions (with callbacks or complex operations)

```rust
// No #[frb(sync)] - FRB generates Future<T> in Dart
pub async fn process_with_storage(
    data: Vec<u8>,
    storage_read: impl Fn(Vec<u8>) -> DartFnFuture<Option<Vec<u8>>> + Send + Sync + 'static,
    // ...
) -> Result<Vec<u8>, String> {
    // async implementation
}
```

## Error Handling

Convert upstream errors to String for FRB:

```rust
pub fn deserialize(bytes: Vec<u8>) -> Result<Self, String> {
    upstream_crate::MyType::deserialize(&bytes)
        .map(|native| MyType { native })
        .map_err(|e| e.to_string())
}
```

FRB automatically converts `Result<T, String>` to Dart exceptions.

## Memory Management

**FRB handles cleanup automatically via Rust's ownership system.**

- No manual `dispose()` needed in Dart
- No finalizers to register
- No double-free concerns
- Opaque types are dropped when Dart GC collects them

```dart
// Dart - no cleanup needed!
final key = MyType.create(param: 'value');
final bytes = key.serialize();
// key is automatically cleaned up when no longer referenced
```

## Vec<u8> for Serialization

Use `Vec<u8>` for all serialized data crossing FFI boundary:

```rust
// Serialize returns Vec<u8>
pub fn serialize(&self) -> Vec<u8> {
    self.native.serialize().to_vec()
}

// Deserialize takes Vec<u8> (or List<int> in Dart)
pub fn deserialize(bytes: Vec<u8>) -> Result<Self, String> {
    // ...
}
```

## Regenerating Bindings

After modifying Rust code in `rust/src/api/`:

```bash
make codegen
```

This runs `flutter_rust_bridge_codegen generate` using `flutter_rust_bridge.yaml` config.

**When to regenerate:**
- After modifying any `pub fn` or `pub async fn` in `rust/src/api/`
- After changing struct/enum definitions
- After updating upstream crate version (if API changed)

## Common Issues

### "method not found" after codegen

- Check that the method is `pub`
- Check that return types are supported by FRB
- Run `make codegen` after any Rust changes

### Callback lifetime issues

Ensure callbacks have `Send + Sync + 'static`:

```rust
callback: impl Fn(Vec<u8>) -> DartFnFuture<Option<Vec<u8>>> + Send + Sync + 'static,
```

### Type not transferable

Use `Vec<u8>` for complex types instead of trying to pass upstream types directly across FFI.

### `block_on` panics

`futures::executor::block_on()` requires a non-async context. This works because FRB runs Rust functions on separate threads. Do NOT call storage callbacks from an async Rust context without `block_on`.

## Web/WASM Considerations

FRB handles web platform differences automatically, but keep in mind:

### RNG on Web
The `getrandom` crate uses Web Crypto API on WASM.
Configuration in `rust/.cargo/config.toml`:
```toml
[target.wasm32-unknown-unknown]
rustflags = ['--cfg', 'getrandom_backend="wasm_js"']
```

### No Threading on WASM
- Avoid `parking_lot::Mutex` in hot paths on web
- Use single-threaded alternatives when possible
- FRB handles this automatically for most cases

### Building WASM
```bash
make build-web
```
